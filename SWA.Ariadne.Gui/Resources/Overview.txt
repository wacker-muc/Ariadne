-----------------------------------------------------------------------

   =================
   Overview: Ariadne
   =================

Copyright (c) Stephan Wacker, 2008

-----------------------------------------------------------------------

The Ariadne application builds and solves a variety of maze puzzles.  When running as a regular application (Ariadne.exe), you can control the maze layout, its shape, additional content etc.  The Ariadne.scr file can be installed as a screen saver.

[Ariadne: Figure from Greek mythology.  Ariadne helped Theseus to escape from the maze where the Minotaurus was held.]

There are several components for specific responsibilities and most of them have many optional features.

-----------------------------------------------------------------------

    The Maze
    ========

The Maze fills a rectangular region in a window.  In screen saver mode, the display is filled completely.

The maze has a tree-like structure.  Any square can be reached from every other square by exactly one solution path.  There are no circles (paths leading from a square to itself).

The maze builder algorithm starts at an arbitrary square and adds it to the "visited" region.  From then on, walls (whose state is initially undecided) beteen one visited and one not-visited square are opened until all squares have been reached.  The remaining walls are closed.

Only closed walls are painted; open walls "do not exist".

    Additional Contents
    -------------------

A plain maze fills the whole area.  However, some regions may be reserved for additional controls or images.  Usually, the reserved areas do not touch directly and the maze flows closely around them.

[Option:] You can specify a directory from which the Screen Saver chooses one or more images (jpg, png, gif) that will be displayed.

[Option:] You can select whether the Screen Saver displays a small panel showing the maze dimension, solver name and run-time statistics.

    Irregular Mazes
    ---------------

Usually, the constructed maze is "regular", uniformly random, i.e. the chances that a specific wall between two adjoining squares are evenly distributed.

In an irregular maze, some directions are preferred over other directions when opening the walls.  The choice may depend on the square's location and on other, opened or closed walls.

[Variants:] There are 20 different methods or patterns of irregular mazes. e.g.:

   * Prefer straight paths: A wall opposite an open wall should also be open.
   * Prefer angled paths: A wall opposite an open wall should be closed.
   * Prefer undulating paths, e.g. east - north - east - south - east - north - etc.
   * Patterns that form structures relative to one or more reference points (usually the center of all or part of the maze):
      * Circles around the reference point.
      * Squares around the reference point.
      * Squares whose corners (at the four diagonals) are turned inside, like the outline of a cross.
      * Vertical and horizontal lines towards the reference point (in four quadrants separated by the diagonals).
      * Radial lines spreading outwards from the reference point.

[Option:] You can select whether irregular mazes may be built.  Five percent of the mazes built in screen saver mode will be irregular.  The irregular choice will be applied to 80% of the walls.

[Variants:] An irregular pattern may also be applied to part of the maze area only; the remainder is regular.  That part is defined by the inside (or outside) of an Outline Shape (see next section).  If an Outline Shape is used for building the maze, that same shape is used for the irregular pattern, as well.  Otherwise a new Outline Shaped may be used for the irregular pattern only.  Another variant is a combination of two different irregular patterns on the inside and outside of the Outline Shape.

    Outline Shapes
    --------------

This option builds continuous closed walls around invisible shapes, e.g. a circle.  Only one wall will be opened so that a path can lead into the shape.  When the solver reaches the outline of the shape, it will run around it and the shape will become visible.  When the solver finds the entry into the shape, it will be filled from the inside but the solver cannot leave the shape as there is no second exit.

Usually, an Outline Shape is one contiguous shape, like a circle, a square or another polygon.  However, an Outline Shape can be any pattern that defines an inside and an outside.  Separate regions are all treated the same way, i.e. they are surrounded by closed walls with a single entry.

[Variants:] There are 15 types of Outline Shapes, most of them with many variants, grouped into seven mayor types:

   * A circle.
   * A diamond, i.e. a square standing on a corner.
   * Symmetric polygons with three to twelve corners.
      * In regular polygons, each corner is connected to the two neighboring corners.
      * In star shaped polygons, each corner is connected to its second / third / n-th neighbor.
   * Two-dimensional functions.  Unlike other shapes that have a limited size, these fill the whole plane with a certain pattern.
      * Horizontal and vertical stripes.
      * Checkered squares.
      * Checkered squares that are rounded along the edges and at the corners.  These allow paths along the edges or between the diagonal corners.
   * Fractals.
      * The Mandelbrot set.
      * Julia sets from generating coordinates near the border of the Mandelbrot set.  An attempt is made to avoid disconnected Julia sets that would be completely indistinguable.
   * Characters and Symbols from fonts at a very large size.
   * Bitmaps that are stored as black-and-white image resources.
      * Geographical structures like continents and countries.

While the patterns evoked by an Irregular Maze Builder come from following preferred directions (if possible), the rules defined by an Outline Shape are very strict.  They take precedence over the irregular preferences.

[Option:] You can select whether Outline Shapes are placed into the maze.  If so, 66% of the screen saver mazes will contain an Outline Shape.

-----------------------------------------------------------------------

    Solver Strategies
    =================

The Solver tries to find a solution path between the start square and the target square.  Some strategies are deterministic, the others make random choices.  Some need to know the location of the target square, some don't.  Most keep a memory of the squares they have already visited.

There are three general types of strategies: Backtrackers, Flooders and Walkers.

Backtrackers go forward until they are caught in a dead end.  Then they go backwards up to a fork with another door they have not yet passed.  There the go forward, then backward, and so on.  A Backtracker can solve any maze.

Flooders follow several concurrent paths in parallel.  For every door at a fork, new open paths are created.  A Flooder can solve any maze without ever going backwards.

Walkers have no memory of visited squares; they decide soleley on their current position and direction.  Two of these implement a classical maze solver algorithm: "Walk through the maze while always touching the wall at your right/left hand side."  This strategy can solve any tree-shaped maze but may be caught in a circle.

The visited paths are painted in two colors: Forward steps are painted in a bright color, backward steps and areas completely covered by a flooder are painted in a dull color.  Two colors with clearly different hue are selected.  When the solution path is found, it is painted in a brighter variant of the forward color.

[Variants:] There are 16 "normal" maze solver strategies:

   * RandomBacktracker:  The classical backtracker algorithm; it walks forward as long as possible, making random choices at a fork.  When there is no continuation, walks back to the latest fork and chooses another path that has not yet been visited (this is called "backtracking").
   * ProximityBacktracker: Another backtracker; at a fork, this one prefers the square that is nearest to the target square (measuring the geometric distance).
   * RightHandWalker: Walks through the maze while staying in touch with the right-hand wall.
   * LeftHandWalker: Walks through the maze while staying in touch with the left-hand wall.
   * RandomFlooder: The classical flooder algorithm:  For every step, choose an arbitrary open path at random.
   * RoundRobinFlooder: This Flooder chooses to continue the open paths in a round-robin sequence, i.e. between two steps on the same path, all other paths are continued, as well.
   * CloseFlooder: This flooder chooses the path closest to the start square.
   * FarFlooder: This flooder chooses the path farthest away from the start square.
   * ProximityFlooder: This flooder chooses the path closest to the target square.
   * HesitatingFlooder: This flooder chooses the path farthest away from the target square.
   * CenterFlooder: This flooder chooses the path closest to the center of the maze.
   * CornerFlooder: This flooder chooses the path farthest away from the center of the maze.
   * ForwardFlooder: This flooder checks all continuations on the open paths and chooses the one with the greatest (relative) distance gain: It chooses the path for which d'/d is minimal, where d is the distance of the current square (on that path) from the target square and d' is the distance of the next square on the path.
   * BackwardFlooder: This flooder works essentially like the ForwardFlooder, but it chooses the path continuation with maximal d'/d ratio.
   * ThickestBranchFlooder: This flooder is based on the maze's tree structure.  Starting with a trunk of thickness 1 and length 0, every step increases the path length by 1 and every fork divides the thickness by the number of branches.  Among the currently thickest branches, the longest one is chosen.
   * ThinnestBranchFlooder: This flooder works like the ThickestBranchFlooder with inverted logic: Among the thinnest branches, the shortest one is chosen.
   
[Variants:] Each of these solvers also has an "efficient" variant.  These employ an algorithm that detects dead ends and avoids these areas.  An area is identified as a dead end if the squares visited by the solver (plus any reserved areas and the maze boundary) form a closed line around it.

Dead end squares are painted with dark gray dots.

There are two additional "extreme" strategies that are, however, not used in screen saver mode or when "any" solver should be selected.

   * RandomWalker: This "solver" has no memory at all.  Every step is chosen randomly.  It may take a very long time (several 100.000 steps) until the target square is found by pure chance.
   * MasterSolver: Knows the solution path beforehand.  Goes directly from start to target without any error.

    Observations
    ------------

The area visited by the RandomBacktracker (in a regular maze) is a good example of a fractal: The border is self-similar at different scales.

RightHandWalker and LeftHandWalker produce "inverted" paintings: One visits all areas to the right of the solution path, the other all areas to the left.

Outline Shapes are completely obliterated when large sections of the maze are visited.  An efficient solver will not paint all squares in the same color and the shape will still be visible.

The ThickestBranchFlooder advances on a chosen branch in one run up to the next fork; then another branch is better than the split branches at the fork.  The percieved movement is rather "jumpy", even at moderate speed.

ForwardFlooder and BackwardFlooder tend to fill the whole maze, just like a HesitatingFlooder.  That is because both solvers assign highest penalties to undesired steps near the target square: the BackwardFlooder assigns an extreme penalty (100%) to the last step onto the target square; the ForwardFlooder assigns very high penalties to backward steps close to the target.  In that situation, both solvers will visit the whole rest of the maze before doing the one highly penalized required step.

Efficient solvers often run for long stretches without error (i.e. without leaving the correct solution path), especially towards the end.  It is not unlikely that such a run spans more than half or two thirds of the solution path.  Even perfect runs without any error at all can be observed.  Considering that an average path may have several dozen or even hundreds of forks, this is quite amazing.

-----------------------------------------------------------------------
